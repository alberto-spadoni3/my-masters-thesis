\chapter{Implementazione}

\section{Piano di Sviluppo}
Il processo di sviluppo del nuovo sistema si è basato sulla metodologia \textit{Agile SCRUM}, con cicli di sviluppo iterativi e incrementali della durata di due settimane (\textit{sprint}). Al termine di ogni sprint, si è tenuto un meeting di revisione con il \textit{project manager} (PM), il quale ha supervisionato lo stato di avanzamento del lavoro, analizzato le criticità emerse e verificato la conformità delle ore lavorate rispetto a quelle preventivate. Durante questi incontri, si sono definite le attività per lo sprint successivo, garantendo un flusso di sviluppo costante e ben organizzato.

\subsection{Ambiente di sviluppo e infrastruttura}
L'ambiente di sviluppo è stato configurato in modo da rispecchiare il più possibile l'ambiente di produzione. Per garantire test realistici, è stata creata una copia del database di produzione su cui eseguire le verifiche funzionali e prestazionali. L'infrastruttura di sviluppo e test è quindi coincidente, consentendo di minimizzare il rischio di errori legati a discrepanze tra ambienti.

\subsection{Struttura della repository e modello di branching}
L'intero codice del progetto è gestito tramite una \textit{monorepo}, ospitata su \textit{GitLab}. La scelta di adottare una monorepo è motivata dalla necessità di mantenere in un unico repository sia il frontend che tutti i microservizi che compongono il backend, semplificando la gestione delle dipendenze, la coerenza tra i moduli e l'esecuzione delle pipeline di \textit{CI/CD}.

Per ottimizzare la gestione della monorepo, è stato utilizzato \texttt{Turborepo}\footnote{\url{https://turbo.build}}, un tool specificamente progettato per lo sviluppo di applicazioni in TypeScript. Turborepo consente di affrontare in modo efficiente il problema dei lunghi processi di compilazione, tipici delle monorepo con numerosi pacchetti e molteplici task (come compilazione, testing e linting). Il tool pianifica l'esecuzione dei task in modo ottimizzato, parallelizzandoli su tutti i core disponibili e implementando un avanzato sistema di caching. Questo permette di ridurre drasticamente i tempi di build successivi al primo, migliorando la produttività del team di sviluppo.

L'organizzazione della monorepo sfrutta la funzionalità \textit{workspace} di \texttt{pnpm}, suddividendo i pacchetti in due macro-categorie:
\begin{itemize}
  \item \textbf{Apps}: Contiene tutti i servizi che vengono eseguiti in maniera indipendente e che costituiscono i diversi microservizi del sistema. Qui sono presenti il frontend e tutti i componenti del backend che operano come unità autonome.
  \item \textbf{Packages}: Include pacchetti di supporto utilizzati dalle \textit{apps}. Tra questi vi sono il package \texttt{commons}, che contiene definizioni e metodi condivisi tra i vari servizi, i pacchetti dedicati alla gestione dello schema di \textit{Prisma} e all'esportazione del client per il database, oltre ai pacchetti per il seeding di quest'ultimo nella fase di test.
\end{itemize}

\subsubsection{Modello di branching}
Per organizzare al meglio il lavoro di sviluppo del team, è stato adottato un modello di branching strutturato, che consente di gestire in modo chiaro e controllato il ciclo di vita del codice. Esso prevede i seguenti branch principali:
\begin{itemize}
  \item \textbf{Main}: Contiene il codice stabile e rappresenta l'unico branch dal quale si effettuano rilasci in produzione.
  \item \textbf{Unstable}: Include le funzionalità candidate al rilascio in produzione. Il codice qui presente è testato in un ambiente di staging prima di essere eventualmente integrato nel branch \textit{main}.
  \item \textbf{Branch personali}: Ogni sviluppatore lavora principalmente su un branch personale, denominato con il proprio cognome, per eseguire i commit delle proprie modifiche prima di unire il codice nei branch condivisi.
  \item \textbf{Feature branches}: Per lo sviluppo di funzionalità specifiche, possono essere creati branch temporanei, indipendenti dai branch personali, in modo da favorire un'organizzazione più modulare del codice.
\end{itemize}

Questa strategia consente di mantenere un flusso di sviluppo ordinato, con chiara separazione tra il codice in produzione, il codice in fase di test e le modifiche in sviluppo. Inoltre, grazie all'integrazione con le pipeline \textit{CI/CD} di \textit{GitLab}, il sistema è in grado di eseguire automaticamente test e build per ogni \textit{push} e \textit{merge request}, garantendo un'elevata affidabilità prima della promozione del codice verso l'ambiente di produzione.

\subsection{Pipeline CI/CD}
L'automazione del processo di sviluppo è stata realizzata attraverso una pipeline di \textit{Continuous Integration/Continuous Deployment} (CI/CD), integrata direttamente in \textit{GitLab}. Il flusso di lavoro della pipeline prevede le seguenti fasi:
\begin{enumerate}
  \item \textbf{Build del codice}: Viene eseguita la compilazione dei vari moduli del progetto per verificare l'assenza di errori strutturali.
  \item \textbf{Esecuzione dei test}: Tutti i pacchetti presenti nella monorepo sono sottoposti a test automatici. Il rilascio procede solo se tutti i test vengono superati con successo.
  \item \textbf{Build per la produzione}: Se i test risultano superati, viene generata una build pronta per il deploy.
  \item \textbf{Deploy sull'ambiente di staging}: Il codice viene infine rilasciato nell'ambiente di staging per ulteriori verifiche prima di un eventuale rilascio in produzione.
\end{enumerate}

\subsection{Test e controllo qualità}
Una componente fondamentale del piano di sviluppo è stata la verifica della qualità del codice e la sua copertura tramite test automatizzati. Il processo di testing ha seguito le seguenti linee guida:
\begin{itemize}
  \item \textbf{Copertura al 100\%} del codice backend e frontend tramite test unitari e di integrazione.
  \item Utilizzo di strumenti di analisi statica del codice come \textit{ESLint} e \textit{Prettier} per garantire standard di qualità e uniformità nella formattazione.
  \item Verifica delle performance e dei comportamenti critici del sistema mediante test prestazionali.
\end{itemize}

\subsection{Approccio alla reingegnerizzazione}
Come descritto nella \Cref{sez:reingegnerizzazione-approcci-fasi}, ogni modello di reingegnerizzazione presenta vantaggi e criticità differenti. Il processo adottato in questo contesto si pone a metà tra l'approccio \textit{Big Bang} e quello \textit{Evolutivo}. Lo sviluppo del nuovo sistema è già avviato e procede in modo incrementale, senza tuttavia una fase di coesistenza con il vecchio. Una volta completato, esso sostituirà integralmente il sistema precedente, fatta eccezione per alcune funzionalità che continueranno a essere gestite dal legacy senza necessità di retrocompatibilità.

La transizione avverrà in modo diretto, senza un rilascio graduale in produzione. Questo semplifica la migrazione, evitando la necessità di interfacce di compatibilità tra i due sistemi. Tuttavia, a differenza di un classico approccio \textit{Big Bang}, lo sviluppo non è stato affrontato come una riscrittura monolitica. Il nuovo sistema, infatti, è stato progettato fin dall'inizio con un'architettura a microservizi, organizzata sulla base delle funzionalità piuttosto che sulla replica della struttura esistente.

Questo approccio ibrido permette di bilanciare i vantaggi dei due modelli. La sostituzione completa del vecchio sistema eliminerà la necessità di mantenere allineate due versioni in parallelo, riducendo la complessità operativa. Allo stesso tempo, l'architettura modulare migliorerà la manutenibilità e faciliterà l'integrazione di nuove tecnologie nel tempo. Questa fusione di metodologie garantirà una transizione più controllata, riducendo il rischio di regressioni e assicurando una maggiore stabilità per il sistema finale.
