\chapter{Implementazione}

\section{Piano di Sviluppo}
Il processo di sviluppo del nuovo sistema si è basato sulla metodologia \textit{Agile SCRUM}, con cicli di sviluppo iterativi e incrementali della durata di due settimane (\textit{sprint}). Al termine di ogni sprint, si è tenuto un meeting di revisione con il \textit{project manager} (PM), il quale ha supervisionato lo stato di avanzamento del lavoro, analizzato le criticità emerse e verificato la conformità delle ore lavorate rispetto a quelle preventivate. Durante questi incontri, si sono definite le attività per lo sprint successivo, garantendo un flusso di sviluppo costante e ben organizzato.

Il team di sviluppo è composto esclusivamente da \textit{Full Stack Developer}, senza una suddivisione rigida tra frontend e backend. Le attività di progettazione grafica non sono state gestite internamente, ma affidate a un designer esterno, incaricato del rinnovo della brand identity. Quindi, per quanto concerne la UI/UX, il team si è solo ocupato di implementare le nuove interfacce grafiche, seguendo le specifiche fornite dal designer.

Per la gestione e il monitoraggio delle attività, è stato utilizzato lo strumento di project management \textit{ClickUp}\footnote{\url{https://clickup.com/}}, che ha permesso di tracciare i task, assegnare priorità e garantire un'organizzazione efficace del lavoro.

Le attività svolte durante gli sprint hanno incluso lo sviluppo di nuove funzionalità, la risoluzione di bug, il refactoring del codice e l'ottimizzazione delle performance. Particolare attenzione è stata dedicata alla qualità del software, con l'integrazione di test automatici e revisioni periodiche del codice prima del rilascio delle feature.

\subsection{Ambiente di sviluppo e infrastruttura}
L'ambiente di sviluppo è stato configurato in modo da rispecchiare il più possibile l'ambiente di produzione, garantendo una maggiore affidabilità nei test e riducendo il rischio di anomalie legate a differenze infrastrutturali. Per ottenere questa uniformità, sono state adottate tecnologie che permettono di replicare fedelmente la configurazione di produzione.

L'intero sistema di sviluppo è stato containerizzato tramite Docker, con i vari servizi orchestrati tramite Docker Compose. Questo permette di avviare l’ambiente di sviluppo in modo rapido e riproducibile su diverse macchine, riducendo problemi di configurazione tra membri del team. Inoltre, l'uso di \textit{Docker-in-Docker} nella pipeline \textit{CI/CD} consente di replicare l’ambiente di esecuzione anche nei job automatici di test e build.

Per la gestione delle configurazioni, ogni microservizio utilizza un file \texttt{.env}, che contiene le variabili d’ambiente necessarie per la configurazione dinamica dello stesso, come le credenziali di accesso ai database e gli endpoint delle API. Durante l’esecuzione della pipeline CI/CD, questo file viene iniettato nei container, permettendo di mantenere un ambiente coerente tra sviluppo, test e produzione, senza la necessità di configurazioni separate per ciascun contesto.

Per migliorare l'affidabilità dei test, è stata implementata una strategia di \textit{seeding} del database, che consente di popolare l’ambiente di test con dati coerenti ad ogni esecuzione, assicurando risultati riproducibili e verifiche affidabili.

\subsection{Struttura della repository}
L'intero codice del progetto è gestito tramite una \textit{monorepo}, ospitata su GitLab. La scelta di adottare una monorepo è motivata dalla necessità di mantenere in un unico repository sia il frontend che tutti i microservizi che compongono il backend, semplificando la gestione delle dipendenze, la coerenza tra i moduli e l'esecuzione delle pipeline di \textit{Continuous Integration/Continuous Deployment} (CI/CD).

Per ottimizzare la gestione della monorepo, è stato utilizzato \texttt{Turborepo}\footnote{\url{https://turbo.build}}, un tool specificamente progettato per lo sviluppo di applicazioni in TypeScript. Turborepo consente di affrontare in modo efficiente il problema dei lunghi processi di compilazione, tipici delle monorepo con numerosi pacchetti e molteplici task (come compilazione, testing e linting). Il tool pianifica l'esecuzione dei task in modo ottimizzato, parallelizzandoli su tutti i core disponibili e implementando un avanzato sistema di caching. Questo permette di ridurre drasticamente i tempi di build successivi al primo, migliorando la produttività del team di sviluppo.

L'organizzazione della monorepo sfrutta la funzionalità \textit{workspace} di \texttt{pnpm}, suddividendo i pacchetti in due macro-categorie:
\begin{itemize}
  \item \textbf{Apps}: Contiene tutti i servizi che vengono eseguiti in maniera indipendente e che costituiscono i diversi microservizi del sistema. Qui sono presenti il frontend e tutti i componenti del backend che operano come unità autonome.
  \item \textbf{Packages}: Include pacchetti di supporto utilizzati dalle \textit{apps}. Tra questi vi sono il package \texttt{commons}, che contiene definizioni e metodi condivisi tra i vari servizi, i pacchetti dedicati alla gestione dello schema di \textit{Prisma} e all'esportazione del client per il database, oltre ai pacchetti per il seeding di quest'ultimo nella fase di test.
\end{itemize}

\subsubsection{Modello di branching}
Per organizzare al meglio il lavoro di sviluppo del team, è stato adottato un modello di branching strutturato, che consente di gestire in modo chiaro e controllato il ciclo di vita del codice. Esso prevede i seguenti branch principali:
\begin{itemize}
  \item \textbf{Main}: Contiene il codice stabile e rappresenta l'unico branch dal quale si effettuano rilasci in produzione.
  \item \textbf{Unstable}: Include le funzionalità candidate al rilascio in produzione. Il codice qui presente è testato in un ambiente di staging prima di essere eventualmente integrato nel branch \textit{main}.
  \item \textbf{Branch personali}: Ogni sviluppatore lavora principalmente su un branch personale, denominato con il proprio cognome, per eseguire i commit delle proprie modifiche prima di unire il codice nei branch condivisi.
  \item \textbf{Feature branches}: Per lo sviluppo di funzionalità specifiche, possono essere creati branch temporanei, indipendenti dai branch personali, in modo da favorire un'organizzazione più modulare del codice.
\end{itemize}

Questa strategia consente di mantenere un flusso di sviluppo ordinato, con chiara separazione tra il codice in produzione, il codice in fase di test e le modifiche in sviluppo. Inoltre, grazie all'integrazione con le pipeline CI/CD di GitLab, il sistema è in grado di eseguire automaticamente test e build per ogni \textit{push} e \textit{merge request}, garantendo un'elevata affidabilità prima della promozione del codice verso l'ambiente di produzione.

\subsubsection{Pipeline CI/CD}
L'automazione del processo di sviluppo è stata realizzata attraverso una pipeline di \textit{CI/CD}, integrata direttamente in GitLab. La pipeline è suddivisa in più fasi, organizzate per garantire una validazione progressiva del codice prima del rilascio in staging.

L'intero processo di build e test si basa su Docker-in-Docker\footnote{\url{https://www.docker.com/resources/docker-in-docker-containerized-ci-workflows-dockercon-2023}} (DinD), una soluzione che permette alla pipeline di eseguire e gestire container Docker all'interno di ambienti di esecuzione basati sulla stessa tecnologia. Questo approccio consente di costruire immagini Docker direttamente nei job della pipeline, riducendo la dipendenza da infrastrutture esterne e garantendo isolamento ed una maggiore coerenza tra gli ambienti di sviluppo, test e deploy.

Il flusso di lavoro della pipeline prevede le seguenti fasi:
\begin{enumerate}
  \item \textbf{Build dell'ambiente di sviluppo}: I servizi vengono compilati e avviati tramite \texttt{docker-compose}, con supporto alla parallelizzazione dei task e caching per ottimizzare i tempi di build.
  \item \textbf{Esecuzione dei test}: Ogni microservizio è testato in container isolati. Viene eseguito il processo di seeding del database per simulare scenari reali e ottenere una copertura completa del codice.
  \item \textbf{Build per la produzione}: Se i test risultano superati, viene generata una build ottimizzata per il rilascio, con tagging e push delle immagini Docker nel registry di GitLab.
  \item \textbf{Deploy sull'ambiente di staging}: Il codice viene distribuito aggiornando i container in esecuzione e ripristinando il database con i dati necessari per il test pre-produzione.
\end{enumerate}

La pipeline utilizza strategie di caching avanzate per ridurre i tempi di esecuzione. I pacchetti \texttt{pnpm} e la cache di \texttt{Turborepo} vengono riutilizzati tra i job, evitando ricompilazioni non necessarie. Inoltre, il sistema di \textit{retry} assicura la ripetizione automatica dei job in caso di errori transitori, migliorando l'affidabilità del processo.

Grazie a questa configurazione della pipeline è possibile garantire un flusso di sviluppo strutturato e sicuro, assicurando che solo codice stabile e testato venga promosso verso l'ambiente di staging e, successivamente, alla produzione.

\subsection{Test e controllo qualità}
Una componente fondamentale del piano di sviluppo è stata la verifica della qualità del codice e la sua copertura tramite test automatizzati. Il processo di testing ha seguito le seguenti linee guida:
\begin{itemize}
  \item \textbf{Copertura al 100\%} del codice backend e frontend tramite test unitari e di integrazione.
  \item Per i test lato backend è stata utilizzata la libreria \texttt{Mocha}\footnote{\url{https://mochajs.org}}, che permette di eseguire test unitari e di integrazione in un ambiente controllato, verificando il corretto funzionamento delle API e della logica applicativa.
  \item Per quelli lato frontend è stato invece adottato \texttt{Playwright}\footnote{\url{https://playwright.dev}}, uno strumento per il testing end-to-end che consente di simulare interazioni utente su più browser. Tuttavia, la copertura dei test frontend è ancora da ampliare per garantire una validazione più completa dell'interfaccia utente.
  \item Utilizzo di strumenti di analisi statica del codice come \texttt{ESLint}\footnote{\url{https://eslint.org}} e \texttt{Prettier}\footnote{\url{https://prettier.io}} per garantire standard di qualità e uniformità nella formattazione.
  \item Verifica delle performance e dei comportamenti critici del sistema mediante test prestazionali.
\end{itemize}

\subsection{Approccio alla reingegnerizzazione}
Come descritto nella \Cref{sec:reingegnerizzazione-approcci-fasi}, ogni modello di reingegnerizzazione presenta vantaggi e criticità differenti. Il processo adottato in questo contesto si pone a metà tra l'approccio ``Big Bang'' e quello ``Evolutivo''. Lo sviluppo del nuovo sistema è già avviato e procede in modo incrementale, senza tuttavia una fase di coesistenza con il vecchio. Una volta completato, esso sostituirà integralmente il sistema precedente, fatta eccezione per alcune funzionalità che continueranno a essere gestite dal legacy senza necessità di retrocompatibilità.

La transizione avverrà in modo diretto, senza un rilascio graduale in produzione. Questo semplifica la migrazione, evitando la necessità di interfacce di compatibilità tra i due sistemi. Tuttavia, a differenza di un classico approccio ``Big Bang'', lo sviluppo non è stato affrontato come una riscrittura monolitica. Il nuovo sistema, infatti, è stato progettato fin dall'inizio con un'architettura a microservizi, organizzata sulla base delle funzionalità piuttosto che sulla replica della struttura esistente.

Questo approccio ibrido permette di bilanciare i vantaggi dei due modelli. La sostituzione completa del vecchio sistema eliminerà la necessità di mantenere allineate due versioni in parallelo, riducendo la complessità operativa. Allo stesso tempo, l'architettura modulare migliorerà la manutenibilità e faciliterà l'integrazione di nuove tecnologie nel tempo. Questa fusione di metodologie garantirà una transizione più controllata, riducendo il rischio di regressioni e assicurando una maggiore stabilità per il sistema finale.

\section{Implementazione della gestione degli errori}
La gestione degli errori rappresenta un aspetto cruciale dell’implementazione del nuovo sistema, garantendo uniformità e coerenza tra backend e frontend. Come descritto nella \Cref{sec:error-management} del capitolo precedente, il design della gestione degli errori è stato strutturato attorno a un modello tipizzato e scalabile, che consente di categorizzare le anomalie in base alla loro natura e al contesto in cui si verificano. In questa sezione verrà illustrata l'implementazione di questo modello, partendo dalla struttura del backend e analizzando successivamente il meccanismo di gestione degli errori nel frontend

\subsection{Gestione degli errori nel backend}
Nel backend, la gestione degli errori è stata implementata attraverso una struttura tipizzata e centralizzata, che garantisce una rappresentazione coerente delle anomalie e facilita la comunicazione con il frontend. Il sistema si basa su una gerarchia di classi che categorizzano le diverse tipologie di errore, sfruttando appieno il sistema di tipi di TypeScript per garantire sicurezza e scalabilità. In questa sezione si analizzeranno nel dettaglio le componenti principali dell’implementazione, tra cui la classe base \texttt{AppError}, il tipo \texttt{AppErrorPayload} e il meccanismo di mappatura degli errori tramite \texttt{ErrorDetailsMapping}.

\subsubsection{Struttura di \texttt{ErrorDetailsMapping}}
Un elemento cardine nella gestione degli errori in questo contesto è la struttura \texttt{ErrorDetailsMapping}, che definisce un sistema di mappatura tra i codici d'errore e le informazioni aggiuntive associate a ciascuno di essi. Questa mappatura consente di tipizzare in modo rigoroso le eccezioni all'interno del sistema, garantendo coerenza tra backend e frontend.

Il tipo \texttt{ErrorDetailsMapping} è stato implementato utilizzando il concetto di \textit{Discriminated union} \footnote{\url{https://www.typescriptlang.org/docs/handbook/2/narrowing.html\#discriminated-unions}}, una tecnica avanzata di TypeScript che permette di creare un'unione di tipi distinti, ciascuno caratterizzato da un identificatore univoco. Questo approccio consente di associare a ogni codice d'errore una specifica struttura dati, evitando il rischio di assegnare dettagli incoerenti o incompleti a una determinata tipologia di errore.

Di seguito è riportata una porzione della definizione di \texttt{ErrorDetailsMapping}:

\lstinputlisting[
  language=typescript,
  caption={Porzione di \texttt{ErrorDetailsMapping}},
label={lst:errorDetailsMapping}]{listings/errorDetails.ts}

La mappatura è organizzata in diverse categorie di errori, ciascuna caratterizzata da una stringa identificativa che segue una convenzione specifica. Ad esempio, gli errori relativi alla validazione degli input sono contrassegnati dal prefisso ``\texttt{validation}'', mentre quelli legati alla gestione delle entità utente utilizzano prefissi come ``\texttt{user}''. Questo schema permette di mantenere un'organizzazione chiara e prevedibile all'interno del codice. Da notare che questi prefissi sono stati scelti in modo da rispecchiare la struttura delle cartelle che usa il frontend per organizzare i file relativi alle traduzioni di tutte le strinche di testo presenti nell'applicazione.

Ogni chiave di \texttt{ErrorDetailsMapping} è associata a un oggetto che definisce i dettagli dell’errore corrispondente. Ad esempio, il codice ``\texttt{user.not\_found}'' è mappato su un oggetto che contiene un solo campo, \texttt{userId}, il quale rappresenta l'identificativo dell'utente che non è stato trovato. Al contrario, errori più complessi, come quelli relativi alla creazione di un utente, includono un campo \texttt{cause} che specifica la motivazione dell'errore. Tale campo è stato anch'esso definito come tipo, sfruttando gli \textit{Union Types}\footnote{\url{https://www.typescriptlang.org/docs/handbook/2/everyday-types.html\#union-types}} di TypeScript su tipi letterali.

Per rendere la gestione degli errori più espressiva e facilmente interpretabile, la definizione dei dettagli di alcuni errori si basa su una gerarchia di tipi, che sfrutta le unioni di stringhe per categorizzare le cause in modo strutturato. Ad esempio, nel caso di un errore durante la creazione di un'entità, la causa può essere una violazione di unicità o un problema di vincolo di chiave esterna nel database. La seguente definizione mostra come tali categorie di errore siano tipizzate:

\lstinputlisting[language=typescript, caption={Definizione del tipo \texttt{cause} per operazioni di creazione}, label={lst:createErrorCause}]{listings/errorTypes.ts}

Questa strategia permette di mantenere un elevato livello di tipizzazione e controllo statico sugli errori generati dal backend. Ogni valore di \texttt{CreateErrorCause} è riconducibile a una stringa specifica che rappresenta la causa esatta dell'errore, evitando di dover gestire messaggi arbitrari e favorendo una comunicazione chiara tra backend e frontend.

Un ulteriore vantaggio di questa struttura è la sua leggibilità. I codici di errore e le relative cause sono stati definiti in modo schematico per essere facilmente convertibili in una stringa leggibile da un umano, permettendo così al frontend di tradurli in messaggi comprensibili per l'utente finale. Questo meccanismo consente di centralizzare la gestione delle stringhe di errore senza doverle definire manualmente nel backend, migliorando la manutenibilità e la scalabilità del sistema.

L'utilizzo di una \textit{Discriminated Union} in questo contesto è particolarmente vantaggioso perché consente di sfruttare il controllo statico dei tipi offerto da TypeScript. In particolare, questa struttura garantisce che:
\begin{itemize}
  \item Ogni codice d’errore sia sempre associato ai dati corretti, evitando ambiguità nella gestione delle eccezioni.
  \item Il frontend possa interpretare correttamente le informazioni restituite dal backend senza necessità di controlli manuali sul tipo dei dati.
  \item L’aggiunta di nuove tipologie di errore sia semplice e non impatti le funzionalità esistenti, rendendo il sistema facilmente estendibile.
\end{itemize}

In sintesi, la struttura \texttt{ErrorDetailsMapping} rappresenta il punto di riferimento per la gestione tipizzata degli errori nel sistema, fornendo un modello scalabile, sicuro e coerente per il trattamento delle anomalie.

\subsubsection{Classe \texttt{AppError}}
La gestione degli errori nel backend si basa anche su una classe astratta denominata \texttt{AppError}, che funge da base per la definizione di tutte le eccezioni applicative. Questa classe fornisce un modello coerente per la rappresentazione degli errori, assicurando che ogni anomalia venga espressa attraverso un formato strutturato e facilmente interpretabile dal sistema. L'obiettivo principale è quello di centralizzare la gestione degli errori, evitando soluzioni dispersive e garantendo una chiara separazione tra la logica applicativa e il trattamento delle anomalie.

Per garantire la massima flessibilità e sicurezza dei tipi, la classe \texttt{AppError} sfrutta i \textit{Generics}\footnote{\url{https://www.typescriptlang.org/docs/handbook/2/generics.html}} di TypeScript. Questo approccio consente di vincolare ogni istanza di errore a un preciso codice identificativo, associandolo a un insieme di dettagli specifici definiti nel tipo \texttt{ErrorDetailsMapping}. Grazie a questa struttura, ogni errore è caratterizzato da tre elementi principali: un codice univoco, uno stato HTTP corrispondente e un set di dettagli contestuali che forniscono informazioni aggiuntive sull'errore.

\lstinputlisting[language=TypeScript,label={lst:appError},caption={Implementazione della classe \texttt{AppError}}]{listings/appError.ts}

\paragraph{Definizione del tipo generico per \texttt{AppError}}
Un elemento fondamentale dell'implementazione della classe \texttt{AppError} è l'uso della keyword \texttt{keyof}\footnote{\url{https://www.typescriptlang.org/docs/handbook/2/keyof-types.html}} durante la definizione del tipo generico \texttt{K}. Questo costrutto di TypeScript, visionabile a riga 2 del \Cref{lst:appError}, consente di ottenere un'unione di stringhe che rappresentano tutti i possibili codici d'errore previsti nel sistema. In altre parole, \texttt{keyof ErrorDetailsMapping} genera dinamicamente un insieme di stringhe che corrispondono esattamente ai nomi delle chiavi definite in \texttt{ErrorDetailsMapping}.
%
Consideriamo, ad esempio, la seguente struttura tipizzata di errori:
\begin{lstlisting}[language=typescript, caption={Esempio di unione di stringhe generate da \texttt{keyof}}]
  "validation.input_error" | "internal.database_error" | "user.create_failed"
\end{lstlisting}
%
Grazie a questo meccanismo, il parametro generico \texttt{K} della classe \texttt{AppError} è automaticamente limitato ai valori validi definiti in \texttt{ErrorDetailsMapping}. In questo modo, qualsiasi istanza della classe d'errore può essere creata solo con un codice conforme alle specifiche del sistema, evitando l'utilizzo di stringhe arbitrarie che potrebbero causare errori di inconsistenza.

\paragraph{Vincolo sul tipo dei dettagli dell’errore}
Oltre a garantire che il codice di errore appartenga a un insieme predefinito, il tipo generico \texttt{K} consente anche di vincolare il formato dei dettagli associati all’errore. Ogni codice d’errore definito in \texttt{ErrorDetailsMapping} è associato a un oggetto contenente informazioni specifiche per quel particolare tipo di anomalia. La classe \texttt{AppError} assicura che il campo \texttt{details} rispetti esattamente la struttura prevista per il codice d’errore selezionato.
%
Ad esempio, se si crea un'istanza di errore per rappresentare un utente non trovato, TypeScript garantirà che i dettagli contengano esclusivamente le proprietà previste per quel tipo di errore. Il codice nel \Cref{lst:appErrorUsage} mostra un caso d’uso concreto:

\lstinputlisting[language=typescript, caption={Esempio di utilizzo della classe \texttt{AppError}}, label={lst:appErrorUsage}]{listings/appErrorUsage.ts}
%
In questo caso, il codice dell'errore è limitato alla stringa ``\texttt{user.not\_found}'', e i dettagli sono strutturati esattamente come specificato in \texttt{ErrorDetailsMapping}. Se si tentasse di fornire un oggetto dettagli con proprietà non conformi, TypeScript genererebbe un errore a tempo di compilazione, impedendo di introdurre inconsistenze nel sistema.

Questa strategia, combinata con il sistema di tipi di TypeScript, permette di mantenere una gestione degli errori robusta, sicura e facilmente estendibile. Nuovi codici d’errore possono essere aggiunti semplicemente aggiornando \texttt{ErrorDetailsMapping}, senza dover modificare la logica esistente o introdurre controlli manuali.

\paragraph{Definizione del tipo \texttt{AppErrorPayload}}
Un altro elemento centrale di \texttt{AppError} è il metodo \texttt{toJSON()}, il quale ha il compito di serializzare l’errore in un formato compatibile con la comunicazione tra backend e frontend. Questo metodo restituisce un oggetto che segue la struttura imposta dal tipo \texttt{AppErrorPayload}, definito nel \Cref{lst:appErrorPayload}.

\newpage
\lstinputlisting[language=typescript, caption={Definizione del tipo \texttt{AppErrorPayload}}, label={lst:appErrorPayload}]{listings/appErrorPayload.ts}
La sintassi utilizzata in questa definizione sfrutta alcune funzionalità avanzate di TypeScript:
\begin{itemize}
  \item \textbf{Mapped Types}: La parte di codice a linea 2 itera su ciascuna chiave \texttt{K} presente in \texttt{ErrorDetailsMapping}. Per ogni chiave, viene creato un nuovo tipo \textit{object} avente due proprietà:
    \begin{itemize}
      \item \texttt{code} di tipo \texttt{K}, che rappresenta il codice d’errore,
      \item \texttt{details} di tipo \texttt{ErrorDetailsMapping[K]}, che contiene i dettagli specifici associati a quel codice.
    \end{itemize}

  \item \textbf{Indexed Access Types}: L'intera mappatura è poi indicizzata con \texttt{[keyof ErrorDetailsMapping]} a linea 6. Questa operazione estrae, dall'oggetto mappato, una unione di tutti i tipi generati per ogni chiave. In altre parole, il risultato finale è una unione dei tipi object definiti per ciascuna chiave in \texttt{ErrorDetailsMapping}.
\end{itemize}

In sintesi, \texttt{AppErrorPayload} rappresenta uno union type, in cui ogni membro dell'unione è un oggetto con due proprietà:
\begin{itemize}
  \item \texttt{code}, il quale contiene un identificativo dell'errore,
  \item \texttt{details}, il quale fornisce informazioni specifiche associate a quell'errore, basate sulla mappatura definita in \texttt{ErrorDetailsMapping}.
\end{itemize}

Questo design consente a \texttt{AppError} di gestire in modo robusto e tipizzato una serie di errori diversi, garantendo che ogni di essi abbia una struttura dati coerente e ben definita.

\subsubsection{Gestione degli errori di validazione degli input}\label{sec:input-validation-errors}
Nel backend, la validazione degli input ricevuti dalle API è affidata alla libreria \texttt{Zod}\footnote{\url{https://zod.dev}}, la quale fornisce un sistema di definizione di schemi e di verifica automatica della conformità dei dati. Quando un input non rispetta lo schema previsto, Zod genera un'eccezione di tipo \texttt{ZodError}, che contiene informazioni dettagliate sugli errori riscontrati. Tuttavia, questo errore non è direttamente utilizzabile per la comunicazione con il frontend, motivo per cui è necessario un processo di elaborazione che trasformi i dati forniti da Zod in un formato strutturato e coerente con il modello di gestione degli errori adottato nel sistema.

A tale scopo, il backend intercetta l’errore lanciato da Zod e lo elabora per costruire un oggetto di tipo \texttt{InputError}. Questo oggetto contiene:
\begin{itemize}
  \item Il nome del campo che ha fallito la validazione.
  \item Un insieme di dettagli strutturati che permettono di comprendere la natura dell'errore.
\end{itemize}
Questi dettagli includono il codice d'errore specifico di Zod (come ``\texttt{too\_small}'', ``\texttt{invalid\_string}'', ``\texttt{unrecognized\_keys}''), il valore atteso e quello effettivamente ricevuto, e altri parametri che variano a seconda del tipo di errore (come i limiti minimi e massimi nel caso di valori numerici o stringhe con vincoli di lunghezza). Ancora una volta l'obiettivo è quello di fornire un’informazione chiara e strutturata, che possa essere facilmente interpretata dal frontend per la generazione di messaggi d’errore dettagliati relativi agli input non validi.

Il risultato di questa elaborazione viene quindi incluso nei \texttt{details} dell’errore con codice ``\texttt{validation.input\_error}'', accompagnato dall’entità coinvolta e dal tipo di operazione che ha generato la validazione fallita. In questo modo, il frontend, ricevendo un errore di questo tipo, è in grado di analizzare i dettagli forniti e costruire dinamicamente un messaggio specifico per ogni campo errato, mantenendo la piena compatibilità con il sistema di internazionalizzazione.

\subsubsection{Conclusione}
La gestione degli errori nel backend è stata strutturata in modo modulare e tipizzato, garantendo uniformità e scalabilità. L’uso dei \textit{generics} di TypeScript e della classe \texttt{AppError} ha permesso di standardizzare la rappresentazione delle anomalie, facilitando l’integrazione con il frontend.

Grazie alla mappatura definita in \texttt{ErrorDetailsMapping}, ogni errore include informazioni specifiche e contestualizzate, assicurando una comunicazione chiara tra i livelli del sistema. Inoltre, la gestione degli errori di validazione tramite Zod permette di trasformare le anomalie sugli input in messaggi strutturati e facilmente interpretabili.

Questa architettura garantisce che il backend restituisca risposte coerenti e prevedibili, semplificando la gestione degli errori lato frontend e migliorando la manutenibilità complessiva del sistema.

\subsection{Gestione degli errori nel frontend}
Nel frontend, il trattamento delle anomalie provenienti dal backend è stato progettato per garantire una comunicazione efficace e multilingua nei messaggi destinati all’utente. Gli errori restituiti dai vari microservizi non possono essere utilizzati direttamente per fornire un feedback comprensibile, poiché si limitano a rappresentare in modo schematico il problema, includendo solo informazioni strutturate e standardizzate. Per questo motivo, è necessario un sistema di interpretazione che analizzi le proprietà dell'oggetto errore e generi dinamicamente un messaggio esplicativo.

L’obiettivo principale di questa strategia è mantenere separata la logica di gestione degli errori dalla costruzione del messaggio visualizzato. In questo modo, il frontend rimane indipendente dalla libreria adottata per la localizzazione dei testi. Questo risultato è ottenuto attraverso il tipo astratto \texttt{Translator}, che funge da callback generica per interagire con il sistema di traduzione scelto.

\paragraph{Definizione e utilizzo di \texttt{Translator}}
Per garantire un efficace supporto alla traduzione dei messaggi di errore, è stato definito il tipo \texttt{Translator}, il quale rappresenta una funzione che riceve una chiave testuale e un insieme opzionale di parametri, restituendo la stringa localizzata corrispondente. La sua definizione è mostrata nel \Cref{lst:translator}.

Per facilitare l’utilizzo del sistema di traduzione nei componenti del frontend, evitando di dover importare ripetutamente la funzione \texttt{useTranslations} di \texttt{next-intl}, è stato realizzato un apposito hook denominato \texttt{useTranslator}. Questo hook consente di definire un prefisso opzionale per le chiavi di traduzione, promuovendo al contempo la separazione della logica di localizzazione da quella di gestione degli errori.
%
\lstinputlisting[language=typescript, caption={Definizione del tipo \texttt{Translator}}, label={lst:translator}]{listings/useTranslator.ts}
%
Grazie a questa astrazione, ogni componente del frontend può ottenere facilmente un’istanza della funzione di traduzione senza dover interagire direttamente con i metodi di \texttt{next-intl}, migliorando la modularità e la manutenibilità del codice.

\subsubsection{Costruzione dinamica dei messaggi di errore}
Nel frontend, ogni volta che viene effettuata una chiamata HTTP al backend, se la risposta ricevuta ha un codice di stato HTTP diverso da \texttt{2XX}, il sistema sa che si è verificato un errore e attiva il meccanismo di generazione del messaggio corrispondente. Per fare ciò, viene analizzato l’oggetto di tipo \texttt{AppErrorPayload} che rappresenta il risultato dell'invocazione del metodo \texttt{toJSON()}, da parte del backend, su un'istanza di \texttt{AppError}.
%
Un primo livello di gestione è implementato attraverso il metodo \texttt{parseBackendError()}, che, sulla base del codice di stato HTTP ricevuto, invoca metodi specifici per la costruzione del messaggio di errore appropriato. In particolare, esso opera come segue:
\begin{itemize}
  \item Se lo stato HTTP è \texttt{400}, si tratta di un errore di validazione. In questo caso, il metodo estrae le informazioni dagli \texttt{inputErrors} e utilizza il metodo \texttt{getValidationErrorMessage()} per generare un messaggio contestualizzato.
  \item Se lo stato HTTP è \texttt{409}, si tratta di un errore di conflitto, tipicamente legato a operazioni fallite su entità esistenti. In questo scenario, il metodo analizza il codice di errore, estraendo il nome dell’entità coinvolta e il tipo di errore. Successivamente, invoca metodi specifici come \texttt{getUserErrorMessage()}, che costruiscono il messaggio contestualizzato all'entità coinvolta.
  \item Se lo stato HTTP è \texttt{500} o un altro valore non gestito, il metodo restituisce un messaggio generico di errore, indicando all’utente che si è verificato un problema imprevisto. Questo è l'unico caso in cui i messaggi d'errore vengono costruiti lato backend, in quanto non è possibile prevedere tutti i possibili scenari. Questi messaggi sono in lingua inglese e non vengono tradotti.
\end{itemize}

% \lstinputlisting[language=typescript, caption={Implementazione del metodo \texttt{parseBackendError}}, label={lst:parseBackendError}]{listings/parseErrors.ts}

\subsubsection{Gestione degli errori relativi alle entità}
Per ogni entità del sistema, come utenti e organizzazioni, gli errori vengono gestiti attraverso metodi dedicati che ne analizzano i dettagli e generano un messaggio leggibile dall’utente. Questa architettura modulare consente di costruire messaggi contestualizzati senza dover gestire manualmente ogni possibile errore all’interno di un’unica funzione centralizzata.

Ogni metodo di gestione degli errori riceve in input tre elementi fondamentali: il tipo di errore riscontrato nei confronti dell'entità coinvolta, i dettagli forniti dal backend la funzione di traduzione \texttt{translator}. L'oggetto dei dettagli contiene informazioni specifiche per ogni errore, come l’identificativo dell’entità coinvolta o la causa del problema. Questi dati vengono utilizzati per personalizzare il messaggio, rendendolo più chiaro e comprensibile per l’utente finale.

All’interno del processo di elaborazione, il valore dei dettagli dell’errore viene interpretato in base alla struttura prevista per la specifica entità, garantendo che i messaggi generati rispettino un formato coerente. Se l’errore riguarda, ad esempio, la creazione di un’entità e contiene una causa associata, questa viene tradotta dinamicamente in un testo comprensibile. O ancora, se l’errore è legato alla ricerca di un’entità non trovata, il messaggio generato include l’identificativo dell’oggetto cercato, fornendo all’utente un’indicazione chiara sul problema riscontrato.

Questa strategia non solo semplifica la gestione degli errori, ma assicura anche una maggiore scalabilità. Nuovi errori possono essere aggiunti senza modificare la logica esistente, garantendo una gestione uniforme e strutturata delle anomalie per tutte le entità del sistema.

\subsubsection{Gestione degli errori di validazione}
Come descritto nella \Cref{sec:input-validation-errors}, gli errori di validazione degli input vengono strutturati in modo da fornire tutte le informazioni necessarie per costruire un messaggio dettagliato. Nel frontend, il metodo \texttt{getValidationErrorMessage()} si occupa di elaborare questi dati per generare una stringa comprensibile e localizzata da mostrare all’utente.
%
\lstinputlisting[language=typescript, caption={Metodo \texttt{getValidationErrorMessage}}, label={lst:getValidationErrorMessage}]{listings/validationMessage.ts}
%
Il metodo analizza gli errori ricevuti, associando ogni campo con i problemi segnalati dal backend. Per ciascuna anomalia, viene costruito un messaggio traducendo dinamicamente il codice d’errore di \texttt{Zod} (ad esempio, ``\texttt{too\_small}'' o ``\texttt{invalid\_string}'') e integrando informazioni come il valore atteso, quello ricevuto e altri dettagli rilevanti. Infine, i vari messaggi vengono concatenati in un'unica stringa strutturata, così da fornire un’indicazione chiara sui problemi riscontrati e facilitare la correzione dei dati inseriti.

\subsubsection{Conclusione}
Il sistema di gestione degli errori nel frontend è stato progettato per garantire scalabilità e supporto alla multilingua, mantenendo un chiaro disaccoppiamento tra la logica di interpretazione e la libreria di internazionalizzazione scelta. L’utilizzo di un tipo astratto come \texttt{Translator} ha permesso di rendere il codice modulare e facilmente adattabile a diverse soluzioni di traduzione, senza dover modificare la logica sottostante.

Grazie a questa architettura, il frontend è in grado di convertire gli errori restituiti dal backend in messaggi informativi chiari e contestualizzati, migliorando l’esperienza utente e garantendo un’interazione fluida con il sistema.
