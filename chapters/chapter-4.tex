\section{Design del nuovo sistema}

Il presente capitolo descrive le scelte architetturali, tecnologiche e progettuali adottate per soddisfare gli obiettivi e i requisiti definiti nel capitolo precedente. L'attenzione si concentra sulle funzionalità sviluppate o analizzate durante il tirocinio, pur accennando alle linee guida per alcune delle funzionalità future, al fine di offrire una visione più completa del sistema.

La progettazione del nuovo sistema punta a superare i limiti identificati nel legacy, adottando un'architettura moderna, modulare e scalabile, che semplifichi la gestione e consenta l'integrazione di nuove funzionalità. Particolare attenzione è stata dedicata alla separazione delle responsabilità tra i vari componenti, alla retrocompatibilità con il sistema attuale e al miglioramento dell'esperienza utente.

Il capitolo è strutturato come segue: dopo una descrizione dell’architettura generale del sistema, si approfondiranno le principali componenti e funzionalità chiave, come la multiutenza e la gestione dei template. Infine, saranno discussi gli aspetti relativi al miglioramento del database e alle strategie messe in campo per garantire la corretta coesione tra i due sistemi.

\section{Architettura generale}

Per la progettazione del nuovo sistema è stata adottata un'architettura a microservizi, caratterizzata da una separazione netta tra frontend e backend. Questa scelta è motivata dalla necessità di superare i limiti architetturali del sistema legacy, introducendo modularità e una chiara separazione delle responsabilità tra i vari componenti.

Nel nuovo sistema, il frontend è rappresentato da un singolo microservizio dedicato alla logica di presentazione dei dati e all'interazione con l'utente. Il backend, invece, è stato suddiviso in molteplici microservizi indipendenti, ciascuno dedicato a un modulo o a una funzionalità specifica dell'applicativo. Questa scomposizione consente di ottenere una maggiore flessibilità, facilitando sia l'aggiunta di nuove funzionalità che la manutenzione del sistema.

I microservizi comunicano tra loro utilizzando il protocollo HTTP e, più specificamente, attraverso API RESTful che ciascuno di essi espone. Queste API vengono inoltre utilizzate sia dal frontend sia per la creazione delle API pubbliche aziendali. Queste ultime, già presenti insieme al sistema legacy, sono state rinnovate per adattarsi alle nuove logiche di funzionamento introdotte nel nuovo sistema.

\subsection{Frontend}
Il frontend è stato progettato come una Single-Page Application (SPA) utilizzando il framework Next.js\footnote{\url{https://nextjs.org}}, scelta che consente di offrire agli utenti un'esperienza fluida ed un accesso rapido da qualsiasi browser, senza bisogno di installare nessun applicativo. Questo microservizio si occupa esclusivamente della logica di presentazione, implementando l'interfaccia grafica e gestendo l'interazione con gli utenti finali.

L'architettura del frontend segue un approccio modulare, in cui ogni pagina e componente è organizzato in base a un sistema di routing gerarchico, denominato App Router\footnote{\url{https://nextjs.org/docs/app}} e facente parte di Next.js. Grazie a tale sistema di routing, la struttura delle cartelle rispecchia direttamente quella degli URL, permettendo una gestione chiara e intuitiva delle varie sezioni dell’applicazione.

Per velocizzare lo sviluppo dell'interfaccia e garantire un design coerente, è stato adottato il template TailAdmin\footnote{\url{https://tailadmin.com}}, una libreria di componenti predefiniti completamente personalizzabili. Questo ha permesso di ridurre il tempo di sviluppo mantenendo comunque la possibilità di adattare l’interfaccia grafica alle esigenze specifiche del progetto. Il template fornisce inoltre pagine già strutturate, che sono state opportunamente modificate per integrarsi con la logica applicativa del sistema.

Un altro aspetto chiave dell'architettura è la gestione dell'autenticazione, implementata tramite la libreria dedicata \texttt{next-auth}\footnote{\url{https://authjs.dev}}. Sebbene Next.js offra la possibilità di definire API direttamente all'interno del frontend, si è scelto di non utilizzare questa funzionalità per la gestione dell'autenticazione. Invece, tale processo è stato demandato a un microservizio che risiede nel backend del sistema, responsabile di tutto ciò che riguarda autenticazione ed autorizzazione.

Anche tutte le operazioni di elaborazione dei dati, come le computazioni o la gestione delle regole di business, sono demandate al backend. Questo approccio garantisce una maggiore coerenza e centralizzazione della logica applicativa, riducendo la complessità del frontend e migliorando la scalabilità del sistema.

\subsection{Backend}
Come già accennato, il backend non è stato concepito come un unico servizio monolitico, ma si è optato per una suddivizione in più microservizi, ciascuno responsabile di una specifica funzionalità o modulo del sistema. Questa scomposizione è stata ottenuta analizzando il sistema legacy, identificando le principali componenti e progettando un microservizio per ognuna di esse.

Tutti i microservizi del backend sono progettati secondo un'architettura uniforme, la quale implementa un servizio Web che espone un'API di tipo REST. Questo standardizzazione agevola lo sviluppo e la manutenzione del backend, rendendo i microservizi facilmente scalabili e intercambiabili. Più in dettaglio, ogni microservizio è strutturato secondo i seguenti livelli:

\begin{itemize}
  \item \textbf{Routes}: file che definiscono tutte le rotte e la loro struttura, specificando i percorsi, i parametri e i metodi HTTP supportati. Questo livello si occupa di mappare le richieste esterne ai rispettivi controller.

  \item \textbf{Controllers}: contengono i metodi responsabili della gestione delle richieste HTTP. I controller ricevono le richieste, ne validano i parametri, delegano l'elaborazione ai servizi, raccolgono i risultati e generano le risposte HTTP in formato JSON.

  \item \textbf{Services}: introducono un grado di astrazione tra i controller e il livello di accesso ai dati (repository). I servizi implementano la logica di business, interagiscono con la base di dati tramite i repository e gestiscono operazioni come la serializzazione e deserializzazione dei dati. Questo strato garantisce che la rappresentazione dei dati sul database sia trasparente agli utilizzatori delle API, come il frontend.

  \item \textbf{Repositories}: rappresentano il livello più vicino ai dati. Qui vengono implementati i metodi che accedono direttamente al database e che eseguono operazioni CRUD specifiche per i vari tipi di dati gestiti. I repository devono rimanere semplici e focalizzati esclusivamente sull'accesso ai dati, senza includere logica di business o presentazione.
\end{itemize}

Questa suddivisione in livelli garantisce una chiara separazione delle responsabilità, migliorando la manutenibilità e la scalabilità del sistema. Inoltre, l'organizzazione del backend in livelli si presta particolarmente bene a contesti come questo, in cui è necessario garantire la retrocompatibilità con una base di dati legacy, avente tabelle malformate. Con questa architettura, i livelli più alti nascondono le logiche implementative sottostanti, permettendo di gestire in modo trasparente eventuali differenze tra il nuovo schema del database e quello esistente. Inoltre, risulta agevole implementare strategie di fallback, permettendo alle funzionalità che devono ancora riferirsi al database legacy di operare senza compromettere il funzionamento generale del sistema.
